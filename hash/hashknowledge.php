Hashing function (散列函式) 在网页应用中被广泛采用，从数码签署、错误检测、登入验证、到压缩储存空间，由于它的原理比较复杂，很多人把它跟加密函式混淆，对于如何运用hash function，如何选择合适的hash function，和它的优点缺点都不清楚，本文尝试解答这些问题。

简单地说，Hashing 是一种数据影射(mapping) 的算法(algorithm)，通常用来把一大串不定长度的数据影射到一个固定长度的、较短的数据，这个固定长度的数据称为hashing value (散列值)。

例如我们把一个由英文字母组成的任意长度的字串，把每一个字符的ASCII 数值加起来，最后除以256 得到的余数作为hash value，这里输入的字串长度没有限制，输出的数值则必定在0 至255 之间，所以是一个合法的hashing function。

以上的hash function 只有256 个可能的hash value，很明显有很多字串都会得到相同的hash value，这种情况我们称为hash collision (散列冲突)，或者简称collision，事实上从一个不定长度的数据影射到一个固定长度的数据，Collision 是无可避免的，我们并不要求完全没有collision，只需把collision 的机会尽量降低便可以了，若果真的要完全没有collision 的话，Hash value 理论上必须与输入的数据长度相同，这样便违背了hash function 的设计目的。

现实应用的hashing function 通常比较复杂，比较有名的包括MD4、MD5、SHA1、SHA256 等，它们的hash value 的数量从2 的几十次方到几百次方。其实我们任何人都可以自行设计一个hashing function，不过基于hashing function 的实际用途，我们对hashing function 有一些基本要求，在进一步解释前，让我们看看hashing 有什么常见的用途。
Hashing 的用途

   1.

      数码签署

      很多提供程式下载的网站，都会在网页上列出下载档案的hash value，比较常见的是MD5 码，下载的人可以自行计算下载回来的档案的hash value 是否与网站提供的相符，从而验证这个程式是否曾经被修改，这个过程就是数码签署。数码签署的概念可以应用在很多通讯领域，例如你要发送一个很重要的电子邮件给别人，为了让收件者放心内容在传送过程中没有被其他人擅改，你可以另外告诉收件人电子邮件的MD5 码，让他自行验证。

      在这种用途中，理想的hashing function 应该具备两种特性，首先是任何对原本文件的改动都会令产生的hash value 改变；第二是没有方法可以得知如何该动原本的文件使计算出来的hash value 相同。

      当然，我们还要确保hash value 不会在传送途中被人拦截并且修改，但这属于通讯安全的问题，超越了hash function 的讨论。
   2.

      错误检测

      资料在网络上传送的时候，会受到很多干扰而使内容改变，其中包括网络问题、电脑硬件问题、电脑程式问题等，为了检验资料的正确性，我们可以一并把资料的hash value 发送给收件者，让收件者比对自行计算的hash value 和收到的hash value 来确认资料的正确性。

      在这种用途种中，理想的hash function 跟上面的要求差不多，就是任何对原本资料的改动都会令产生的hash value 改变。
   3.

      登入验证

      在伺服器上储存用户的系统密码是有风险的，第一这样做等于把密码的安全交托给伺服器管理员，他们一定可靠吗？别忘记密码万一泄漏背黑镬的是你而不是他们啊；第二很多用户把相同的密码应用在很多不同的系统（这样做当然很不好，但你无法限制用户不可以这样做），当一个系统被黑客入侵泄漏了用户的密码，他们在其他系统的帐号也同时中门大开，后果可以很严重。为了保障用户，设计良好的系统都不会直接储存用户的密码，只会储存密码的hash value。用户登入时输入的密码，会被转换成hash value，然后与伺服器上储存的hash value 比较来进行身分验证。

      这种用途的hash function，必须是不可能返过来从hash value 计算原本的密码。此外，由于collision 的缘故，只要找到一个密码，它的hash value 与用户的密码的hash value 相同，便可以冒认这名用户登入系统，无须知道真正的密码，所以hash value 的数量必须非常庞大，使collision 的可能性很低很低，使寻找这个「伪冒」密码的人要付出很大的代价。
   4.

      压缩储存空间

      Hash function 其中一个最经典的用途是制作hashing table (散列表)，它可说是一个关联阵列(associative array)，阵列的指标是一些不定长度的数据或者是比较复杂的数据结构，很多高阶编程语言包括PHP、Perl、gawk 等都支援关连阵列，背后的原理就是利用hash function 把这些数据转换成数字，然后读取阵列中的元素。在大部分的情况下，作为阵列指标的数据可以非常庞大，但是阵列的长度(元素的数量) 相对来说却很少，所以冲突的情况会比较突出，从用户(编程人员) 的角度冲突是不应该发生的，不同的数据便应该对应到不同的阵列位置，所以这些语言都有某些方法来处理冲突。

      用hash table 来实作关联阵列的好处是搜索资料的速度高，无论有多少资料，搜索的速度都是固定的，这一点对于要处理大量数据的应用很重要。

PHP 有什么 hashing 工具？

Hash Functions Hash value 的长度 (bit) 
CRC32 32 
MD5 128 
SHA-1 160 

（本站转载备注：在PHP5.12以后可以使用 hash_algos()返回所有的hash算法，并从手册上得知现支持 35种算法；查看手册）

在PHP5 之前我们只有CRC32、MD5 和SHA1 三个内置的hash function，它们输出的hash value 长度如下：
Hash Functions Hash value 的长度 (bit)
CRC32 32
MD5 128
SHA-1 160

其中SHA-1 可说是最多人使用的hash function，原因是它的hash value 比其他的大，Collision 的机会便小得多。其次SHA 家族的hashing functions 是由美国国家安全部(NSA – National Security Agency) 设计，并被列为美国联邦资讯处理标准的一部分，所以给人较高的信心，很多复杂的安全方案例如SSL 都使用SHA-1。

PHP 还有两个需要额外安装的函式库支援更多hash function，就是mhash 和hash，Hash 从PHP 5.1.2 开始列为标准的模组，无须自行编译或安装，所以越来越多人使用。一些比SHA-1 更先进的hash function 都可以在这两个函式库中找到，例如属于SHA-2 家族的SHA-256 和SHA-512 等，不过由于SHA-1 的历史比较悠久，很多系统仍然继续使用它，尤其是用SHA-1 来进行登入验证的系统，由于hash function 的不可还原性，很难一下子改用其他hash function。

使用SHA-1 的方法很简单(PHP 的函式大都很简单，不是吗？)：

echo sha1(‘I am a happy boy.’);

Hash 的用法也很简单：

echo hash(‘sha256′, ‘I am a happy boy.);

Hash 支援很多hash function，可以用hash_algo 查看你的PHP 版本支援什么：

print_r(hash_algos());

http://www.pbdigg.net/show.php?tid=47894


1. 给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？ 


方案1：可以估计每个文件安的大小为50G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。



s 遍历文件a，对每个url求取，然后根据所取得的值将url分别存储到1000个小文件（记为）中。这样每个小文件的大约为300M。



s 遍历文件b，采取和a相同的方式将url分别存储到1000各小文件（记为）。这样处理后，所有可能相同的url都在对应的小文件（）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。



s 求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。



方案2：如果允许有一定的错误率，可以使用Bloom filter，4G内存大概可以表示340亿bit。将其中一个文件中的url使用Bloom filter映射为这340亿bit，然后挨个读取另外一个文件的url，检查是否与Bloom filter，如果是，那么该url应该是共同的url（注意会有一定的错误率）。



2. 有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。



方案1：



s 顺序读取10个文件，按照hash(query)%10的结果将query写入到另外10个文件（记为）中。这样新生成的文件每个的大小大约也1G（假设hash函数是随机的）。



s 找一台内存在2G左右的机器，依次对用hash_map(query, query_count)来统计每个query出现的次数。利用快速/堆/归并排序按照出现次数进行排序。将排序好的query和对应的query_cout输出到文件中。这样得到了10个排好序的文件（记为）。



s 对这10个文件进行归并排序（内排序与外排序相结合）。



方案2：



一般query的总量是有限的，只是重复的次数比较多而已，可能对于所有的query，一次性就可以加入到内存了。这样，我们就可以采用trie树/hash_map等直接来统计每个query出现的次数，然后按出现次数做快速/堆/归并排序就可以了。



方案3：



与方案1类似，但在做完hash，分成多个文件后，可以交给多个文件来处理，采用分布式的架构来处理（比如MapReduce），最后再进行合并。



3. 有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。



方案1：顺序读文件中，对于每个词x，取，然后按照该值存到5000个小文件（记为）中。这样每个文件大概是200k左右。如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，知道分解得到的小文件的大小都不超过1M。对每个小文件，统计每个文件中出现的词以及相应的频率（可以采用trie树/hash_map等），并取出出现频率最大的100个词（可以用含100个结点的最小堆），并把100词及相应的频率存入文件，这样又得到了5000个文件。下一步就是把这5000个文件进行归并（类似与归并排序）的过程了。



4. 海量日志数据，提取出某日访问百度次数最多的那个IP。



方案1：首先是这一天，并且是访问百度的日志中的IP取出来，逐个写入到一个大文件中。注意到IP是32位的，最多有个IP。同样可以采用映射的方法，比如模1000，把整个大文件映射为1000个小文件，再找出每个小文中出现频率最大的IP（可以采用hash_map进行频率统计，然后再找出频率最大的几个）及相应的频率。然后再在这1000个最大的IP中，找出那个频率最大的IP，即为所求。



5. 在2.5亿个整数中找出不重复的整数，内存不足以容纳这2.5亿个整数。



方案1：采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需内存内存，还可以接受。然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可。



方案2：也可采用上题类似的方法，进行划分小文件的方法。然后在小文件中找出不重复的整数，并排序。然后再进行归并，注意去除重复的元素。



6. 海量数据分布在100台电脑中，想个办法高校统计出这批数据的TOP10。



方案1：



s 在每台电脑上求出TOP10，可以采用包含10个元素的堆完成（TOP10小，用最大堆，TOP10大，用最小堆）。比如求TOP10大，我们首先取前10个元素调整成最小堆，如果发现，然后扫描后面的数据，并与堆顶元素比较，如果比堆顶元素大，那么用该元素替换堆顶，然后再调整为最小堆。最后堆中的元素就是TOP10大。



s 求出每台电脑上的TOP10后，然后把这100台电脑上的TOP10组合起来，共1000个数据，再利用上面类似的方法求出TOP10就可以了。



7. 怎么在海量数据中找出重复次数最多的一个？



方案1：先做hash，然后求模映射为小文件，求出每个小文件中重复次数最多的一个，并记录重复次数。然后找出上一步求出的数据中重复次数最多的一个就是所求（具体参考前面的题）。



8. 上千万或上亿数据（有重复），统计其中出现次数最多的钱N个数据。



方案1：上千万或上亿的数据，现在的机器的内存应该能存下。所以考虑采用hash_map/搜索二叉树/红黑树等来进行统计次数。然后就是取出前N个出现次数最多的数据了，可以用第6题提到的堆机制完成。



9. 1000万字符串，其中有些是重复的，需要把重复的全部去掉，保留没有重复的字符串。请怎么设计和实现？



方案1：这题用trie树比较合适，hash_map也应该能行。



10. 一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。



方案1：这题是考虑时间效率。用trie树统计每个词出现的次数，时间复杂度是O(n*le)（le表示单词的平准长度）。然后是找出出现最频繁的前10个词，可以用堆来实现，前面的题中已经讲到了，时间复杂度是O(n*lg10)。所以总的时间复杂度，是O(n*le)与O(n*lg10)中较大的哪一个。



11. 一个文本文件，找出前10个经常出现的词，但这次文件比较长，说是上亿行或十亿行，总之无法一次读入内存，问最优解。



方案1：首先根据用hash并求模，将文件分解为多个小文件，对于单个文件利用上题的方法求出每个文件件中10个最常出现的词。然后再进行归并处理，找出最终的10个最常出现的词。



12. 100w个数中找出最大的100个数。



方案1：在前面的题中，我们已经提到了，用一个含100个元素的最小堆完成。复杂度为O(100w*lg100)。



方案2：采用快速排序的思想，每次分割之后只考虑比轴大的一部分，知道比轴大的一部分在比100多的时候，采用传统排序算法排序，取前100个。复杂度为O(100w*100)。



方案3：采用局部淘汰法。选取前100个元素，并排序，记为序列L。然后一次扫描剩余的元素x，与排好序的100个元素中最小的元素比，如果比这个最小的要大，那么把这个最小的元素删除，并把x利用插入排序的思想，插入到序列L中。依次循环，知道扫描了所有的元素。复杂度为O(100w*100)。



13. 寻找热门查询：



搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录，这些查询串的重复读比较高，虽然总数是1千万，但是如果去除重复和，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就越热门。请你统计最热门的10个查询串，要求使用的内存不能超过1G。



(1) 请描述你解决这个问题的思路；



(2) 请给出主要的处理流程，算法，以及算法的复杂度。



方案1：采用trie树，关键字域存该查询串出现的次数，没有出现为0。最后用10个元素的最小推来对出现频率进行排序。



14. 一共有N个机器，每个机器上有N个数。每个机器最多存O(N)个数并对它们操作。如何找到个数中的中数？



方案1：先大体估计一下这些数的范围，比如这里假设这些数都是32位无符号整数（共有个）。我们把0到的整数划分为N个范围段，每个段包含个整数。比如，第一个段位0到，第二段为到，…，第N个段为到。然后，扫描每个机器上的N个数，把属于第一个区段的数放到第一个机器上，属于第二个区段的数放到第二个机器上，…，属于第N个区段的数放到第N个机器上。注意这个过程每个机器上存储的数应该是O(N)的。下面我们依次统计每个机器上数的个数，一次累加，直到找到第k个机器，在该机器上累加的数大于或等于，而在第k-1个机器上的累加数小于，并把这个数记为x。那么我们要找的中位数在第k个机器中，排在第位。然后我们对第k个机器的数排序，并找出第个数，即为所求的中位数。复杂度是的。



方案2：先对每台机器上的数进行排序。排好序后，我们采用归并排序的思想，将这N个机器上的数归并起来得到最终的排序。找到第个便是所求。复杂度是的。



15. 最大间隙问题



给定n个实数，求着n个实数在实轴上向量2个数之间的最大差值，要求线性的时间算法。



方案1：最先想到的方法就是先对这n个数据进行排序，然后一遍扫描即可确定相邻的最大间隙。但该方法不能满足线性时间的要求。故采取如下方法：



s 找到n个数据中最大和最小数据max和min。



s 用n-2个点等分区间[min, max]，即将[min, max]等分为n-1个区间（前闭后开区间），将这些区间看作桶，编号为，且桶的上界和桶i+1的下届相同，即每个桶的大小相同。每个桶的大小为：。实际上，这些桶的边界构成了一个等差数列（首项为min，公差为），且认为将min放入第一个桶，将max放入第n-1个桶。



s 将n个数放入n-1个桶中：将每个元素分配到某个桶（编号为index），其中，并求出分到每个桶的最大最小数据。



s 最大间隙：除最大最小数据max和min以外的n-2个数据放入n-1个桶中，由抽屉原理可知至少有一个桶是空的，又因为每个桶的大小相同，所以最大间隙不会在同一桶中出现，一定是某个桶的上界和气候某个桶的下界之间隙，且该量筒之间的桶（即便好在该连个便好之间的桶）一定是空桶。也就是说，最大间隙在桶i的上界和桶j的下界之间产生。一遍扫描即可完成。



16. 将多个集合合并成没有交集的集合：给定一个字符串的集合，格式如：。要求将其中交集不为空的集合合并，要求合并完成的集合之间无交集，例如上例应输出。



(1) 请描述你解决这个问题的思路；



(2) 给出主要的处理流程，算法，以及算法的复杂度；



(3) 请描述可能的改进。



方案1：采用并查集。首先所有的字符串都在单独的并查集中。然后依扫描每个集合，顺序合并将两个相邻元素合并。例如，对于，首先查看aaa和bbb是否在同一个并查集中，如果不在，那么把它们所在的并查集合并，然后再看bbb和ccc是否在同一个并查集中，如果不在，那么也把它们所在的并查集合并。接下来再扫描其他的集合，当所有的集合都扫描完了，并查集代表的集合便是所求。复杂度应该是O(NlgN)的。改进的话，首先可以记录每个节点的根结点，改进查询。合并的时候，可以把大的和小的进行合，这样也减少复杂度。



17. 最大子序列与最大子矩阵问题



数组的最大子序列问题：给定一个数组，其中元素有正，也有负，找出其中一个连续子序列，使和最大。



方案1：这个问题可以动态规划的思想解决。设表示以第i个元素结尾的最大子序列，那么显然。基于这一点可以很快用代码实现。



最大子矩阵问题：给定一个矩阵（二维数组），其中数据有大有小，请找一个子矩阵，使得子矩阵的和最大，并输出这个和。



方案1：可以采用与最大子序列类似的思想来解决。如果我们确定了选择第i列和第j列之间的元素，那么在这个范围内，其实就是一个最大子序列问题。如何确定第i列和第j列可以词用暴搜的方法进行。代码详见我的博客。

